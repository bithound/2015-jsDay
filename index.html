<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>bitHound</title>

    <meta name="description" content="">
    <meta name="author" content="bitHound">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <link rel="icon" href="img/symbol_colour.png" type="image/x-icon">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/bithound.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <script src="http://localhost:35729/livereload.js?snipver=1"></script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        <section class="main-title" data-background="img/symbol_reversed.svg" data-background-size="150%">
          <img src="img/fulllogo_reversed.svg" class="simple-img full-logo" />
          <h3>The other side of DevOps:</h3>
          <h3>Virtualization to support JavaScript Developers</h3>
          <p>
            <small>Presented by Tony Thompson</small><br />
            <a href="https://www.bithound.io">www.bithound.io</a> / <a href="http://twitter.com/bithoundio">@bithoundio</a>
          </p>  
        </section>

<!--
        <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
          <h2>Who am I?</h2>
          <h3><a href="https://www.bithound.io">www.bithound.io</a></h3>
          <br>
        </section>
  -->

        <section>
          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <h2>DevOps</h2>
          </section>
   
          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <br>
            <aside class="notes">
I've heard some people describe DevOps as 'sysadmins who program'.  And that's
not entirely true.  Sysadmins have been programming since dinosaurs ruled the
machine room.  Who do you think uses languages like bash or perl or awk?
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <br>
            <aside class="notes">
In the 'bad old days', a dev team would finish up, toss a product over the wall to the systems team 
who then would then have the curse of deploying it.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <br>
            <aside class="notes">
So I guess what I'm trying to say, is that as a DevOps guy, if a dev team comes
to me with a product and says 'deploy this!', it's already too late.  We're
going to miss the deadline.  This is especially true for node.js/io.js.
Apache/nginx support for js is pretty primitive, and OS distributions lag
badly.

As somebody with fifteen years of sysadmin experience, I <em>hate</em> running
software that's not well maintained upstream.

The goal of DevOps is to get ahead of mere 'sysadmin' concerns.  And that's not
just a matter of applying developer tools to operations; it's also important to
bring operations tools and culture into the developer world.
            </aside>
          </section>
        </section>


        <section>
          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <h2>Tools</h2>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <img src="img/acme.jpg">
            <aside class="notes">
Bash is the Cowbell of DevOps
<br>
Really, what you want in a virtualizer from Ops perspective is really the same thing you want in any other software 
There's nothing in this talk that couldn't be done in puppet.  Or powershell.  Or as grunt scripts.
bitHound tends to be a mac/linux shop, and bash is a cheap / fast / universal tool for us.
<br>
I like using tools that let me duct tape together other tools.  So bash it is.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
<blockquote>
&ldquo;The only DevOps tool is someone with the title &lsquo;Director of DevOps&rsquo;.&rdquo;
<br>
<br>
<div style="float:right">
 -- @nathenharvey
</div>
<div style="clear: both"></div>
</blockquote>

            <aside class="notes">
At it's heart, DevOps is an approach; a culture.  To really do devops right,
your entire organization has to be geared towards building deployable software.
The entire point of DevOps is to not to have silos; there really aren't any
software tools that are DevOps specific.  You shouldn't choose new tools
because they are more devops-y.  And if your under pressure to use a given tool
'because devops', then something isn't right.
<br>
There is no tool that "gives you devops".  However, vagrant and bash are a good place to start.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <ul>
              <li>Vagrant</li>
              <li>Docker</li>
              <li>VirtualBox</li>
              <li>VMware</li>
            </ul>

            <aside class="notes">
Really, what you want in a virtualizer from Ops perspective is really the same thing you want in any other software 
from a devs perspective.  You want something that can be scripted, and is supported in your organization.
            </aside>
          </section>

        </section>

        <section>
          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <h2>Challenge 1:<br>Virtualization is Slow!</h2>
          </section>

          <section data-background="img/slow.gif">
            <aside class="notes">
Define slow.
<br>
But 'slow' is a pretty vague term.  Is it CPU, Network, Storage, Memory constraint.
<br>
Ultimately, Speed isn't the point.  Consistency and convention are the points.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
<img src="img/64kb.png" alt="">
<a class="small" href="http://mitchellh.com/comparing-filesystem-performance-in-virtual-machines">http://mitchellh.com/comparing-filesystem-performance-in-virtual-machines</a>
            <aside class="notes">
Bigger is better.  So here you can see that for small files, NFS outperforms VirtualBox native filesystems.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
<img src="img/64kb_write.png" alt="">
<a class="small" href="http://mitchellh.com/comparing-filesystem-performance-in-virtual-machines">http://mitchellh.com/comparing-filesystem-performance-in-virtual-machines</a>

            <aside class="notes">
But not when it comes to writes.  
So running a virtualized filestem, NFS, or through your virtualizer to the host VM all have different types of performance.

Benchmark, benchmark, benchmark.  Your app is a unique snowflake.
For example, we have our code mounted in via NFS, but our app's scratch space is on a virtual HD that is not available to the host.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
<pre>
#!/bin/bash
nodemon \
  -e js,html,css \
  --exec "bash ./restart.sh" 
</pre>
            <aside class="notes">
Also, it's possible to work around some of these issues.  For example, we know file reads are slow, right?
That makes it things like <code>nodemon</code> also very slow.

But we don't have to run it inside the VM.  It's not part of our production setup!  There's no reason we can't take
that and run it in the host environment.  I'll get into where we'd stash this in the next session.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
<pre>
Vagrant.configure(2) do |config|

  config.vm.provider :virtualbox do |vb|
    vb.cpus = 3
    vb.memory = 2048
    vb.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
    vb.customize ["modifyvm", :id, "--natdnsproxy1", "on"]
  end

end
</pre>
            <aside class="notes">
Most VMs can be tuned to meet your needs.  Vagrant defualt is (I htink) 512MB of RAM and a single CPU.
<br>
This kind of tuning helps, but regardless, your app will not be as fast inside a virtualizer -- no matter
which one -- as it is on bare metal.  But keep in mind, you're almost certainly deploying to a virtualized
environment.  Unless you own your own hardware.
            </aside>
          </section>

        </section>

        <section>
          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <h2>Challenge 2:<br>Virtualization is <em>Not</em> Transparent to Developers</h2>
            <aside class="notes">
Not if you have to run scripts inside the environment.
            </aside>
          </section>

          <section data-background="img/popup.gif">
            <aside class="notes">
If your app is virtualized, as a dev, you are (naturally) separated from your running code.
Vagrant actually gets us about halfway there -- mounting in <code>/vagrant</code> by default
was a brilliant design decision.  You can do that in every other virutalizer, too.  But setting
it up takes <em>work</em>.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
<pre>
|-- Vagrantfile
|-- Dockerfile
|-- app 
|-- bin
|   |-- start.sh
|   +-- stop.sh
|-- etc
+-- scripts
    |-- provision.sh
    |-- deploy.sh
    +-- scripts.sh
</pre>
            <aside class="notes">
We actually have two separate places where we keep scripts.  Our main repo looks something like this:
<br>
And just to make things difficult, we keep our systems level code in a seperate repo from our actual app.
We include the app as a submodule.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
<pre>
|-- Vagrantfile
|-- Dockerfile
|-- app
|   |-- bin
|   |   |-- start.sh
|   |   +-- stop.sh
|   +-- scripts
|       +-- migrate.sh 
|-- bin
|   |-- start.sh
|   +-- stop.sh
|-- etc
+-- scripts
    |-- provision.sh
    |-- deploy.sh
    +-- scripts.sh
</pre>
            <aside class="notes">
If we pull in that submodule, our directory path looks like this.  So scripts
that are in 'app/bin' handle regular operation (e.g. starting, stopping) our
app within the vim.  'bin' handles the same, but from the host.  'bin/scripts'
holds our app specific management scripts and 'scripts' holds our system wide,
common scripts.
<br>
This is our convention.  There are many like it, but this works for us at
bitHound.  So depending on your path, you can tell if you are trying to
interact from inside or outside the guest.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
<pre>
#!/bin/bash

#start app
vagrant ssh --command "cd /vagrant/app &amp;&amp; ./bin/cli server start"
</pre>
            <aside class="notes">
So here's a really naive way of starting an app in a vagrant box.  This runs, but never comes back. 
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
<pre>
#!/bin/bash

#start app
vagrant ssh --command "cd /vagrant/app &amp;&amp; ./bin/cli server start &amp;"
</pre>
<hr>
<pre>
#!/bin/bash

#start app
vagrant ssh --command "cd /vagrant/app &amp;&amp; ./bin/cli server start" &amp;
</pre>
            <aside class="notes">
So we can push it into the background, either on the guest or the host, but we don't have a handle or a way to stop or restart the app.
            </aside>
          </section>


          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
<pre>
#!/bin/bash

#start app
vagrant ssh --command "cd /vagrant/app; forever --uid 'app' -a start ./bin/cli server start"
</pre>
            <aside class="notes">
And here's a version using 'forever'.  It's a JS tool that's a lot like supervisor.  It's built to manage
long running processes.  E.g.: start, stop, restart.  Here, it's running inside the guest, but we're managing it 
from the host.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <br>
<pre>
#!/bin/bash

vagrant ssh --command "cd /vagrant/app &amp;&amp; ./bin/bithound.js $*"
</pre>
            <aside class="notes">
Utility / proxy scripts to interact with your project inside the VM.  You could call this a trampoline or a thunk, uh, 
if you lived through the win16 to win32 transition. (I didn't, but I was just after that and still had to deal
with old developer documentation.
<br>
$* is just the parameter list that this program has been called with itself.  
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <img src="img/ssh.gif">
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
Vagrant files in particular are just ruby!
<pre>
unless Vagrant.has_plugin?('vagrant-s3auth')
  # Attempt to install ourself. Bail out on failure so we don't get
  # stuck in an infinite loop.
  system('vagrant plugin install vagrant-s3auth') || exit!

  # Relaunch Vagrant so the plugin is detected.
  # Exit with the same status code.
  exit system('vagrant', *ARGV)
end
</pre>
          </section>
        </section>

        <section>
          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <h2>Challenge 3:<br>Production <em>will</em> differ</h2>
            <aside class="notes">
Different deployment locations in the filesystem.  Different users.  Different security contexts.  Different environments.
            </aside>
          </section>

          <section data-background="img/fridgeski.gif">
            <aside class="notes">
Virtualization as tool can give your dev team an approximation of production.  It's up to your ops team to make
that approximation as close as possible.
<br>
Ultimately, there is no good answer.  Vagrant isn't quite what it says on the label -- you have to be aware of the ways
in which your vagrant environment differs from your production environment.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
<pre>
Vagrant.configure(2) do |config|
  config.vm.define "app" do |app|
    app.vm.box = "trusty64"
    app.vm.provision "shell", path: "scripts/provision_app.sh"
    app.vm.network "private_network", ip: "10.10.11.11"
  end

  config.vm.define "worker1" do |worker|
    worker.vm.box = "trusty64"
    worker.vm.provision "shell", path: "scripts/provision_worker.sh"
    worker.vm.network "private_network", ip: "10.10.11.12"
  end

  config.vm.define "worker2" do |worker|
    worker.vm.box = "trusty64"
    worker.vm.provision "shell", path: "scripts/provision_worker.sh"
    worker.vm.network "private_network", ip: "10.10.11.13"
  end
end
</pre>
            <aside class="notes">
So if you are building a distributed system, develop on a distributed system!  Almost all virtualization environments
right now allow you define multiple VMs and private networks.
            </aside>
          </section>


          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
<pre>
#!/bin/bash

#start app
vagrant ssh app --command "cd /vagrant/app;   forever --uid 'app' -a start ./bin/cli server start"

#start workers
vagrant ssh worker1 --command "cd /vagrant/app; forever --uid 'worker' -a start ./bin/bithound.js worker 10.10.11.11"
vagrant ssh worker2 --command "cd /vagrant/app; forever --uid 'worker' -a start ./bin/bithound.js worker 10.10.11.11"
</pre>
            <aside class="notes">
            </aside>
          </section>

        </section>

        <section>
          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <h2>Challenge 4:<br>Provisioning is hard</h2>
          </section>

          
          <section data-background="img/paint.gif">
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            Provisioners
            <br>
            <ul>
              <li>Chef</li>
              <li>Puppet</li>
              <li>Ansible</li>
              <li>CFEngine</li>
              <li>Cobbler</li>
              <li>SaltStack</li>
            </ul>
            <aside class="notes">
Chef, Puppet or Ansible are all pretty heavy for small projects.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <ul>
              <li>Configuration Management</li>
              <li>Orchestration</li>
              <li>Verification / Auditing</li>
            </ul>

            <aside class="notes">
We only really care about the configuration management part.  Our VM environment handles orchestration.  And we really
don't care about verification.  We're taking a very 

If there are changes to the environment that are permanent, they <em>must be scripted and committed</em>.  The configuration
as present in version control is the gold standard.

So if you suspect that your dev environment has gone off the rails, but you do have a good provisioning script, don't bother
auditing.  Just nuke it from orbit, and create a new one.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <ul>
              <li>Configuration Management</li>
              <li><strike>Orchestration</strike></li>
              <li><strike>Verification / Auditing</strike></li>
            </ul>

            <aside class="notes">
As long as your provisioner is idempotent, you can provision with just about any tool.
Don't try to modify config files in place.  Just check 'em in, and copy them into place.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <br>
<pre>
#!/bin/bash 
BASE='/vagrant'

apt-get update
apt-get install -y build-essential curl git mongodb-clients nginx tmux vim

cp "$BASE/etc/nginx/nginx.conf" /etc/nginx/nginx.conf

npm -g install forever
npm -g install nodemon
</pre>

            <aside class="notes">
Here's a really early version of our provision script.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <br>
<pre>
Vagrant.configure(2) do |config|
  config.vm.provision "shell", path: "scripts/provision.sh"
end
</pre>

            <aside class="notes">
And then calling a shell provisioner is really difficult.
In real life, we have parameters that we can pass to our provisioning script.  We can tell it
what user our app will run as, and what the source and destination paths actually are.

We actually use the same scripts to provision our dev machines and our production machines.
            </aside>
          </section>
        </section>

        <section>
          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <h2>Challenge 5:<br>Keeping it going.</h2>
            <aside class="notes">
We don't need maintenance because devs regularly destroy and rebuild their vagrant environments, right?
            </aside>
          </section>

          <section data-background="img/catapult.gif">
            <aside class="notes">
Just because you've built a virtual dev environment, doesn't mean it will stay
in sync.  Your upstream images may change.  There will be security updates.
Your own application may change.  If you don't regularly rebuild your dev
environment, You will be surprised.
<br>
And that's the best case.  If you do a lot of work in a particular guest, your
dev evnironment as running may no longer match your dev environment as spec'd.
If you don't reprovision regularly, you will drift out of sync and lose many of
the benefits of virtualization.
            </aside>
          </section> 

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <h3>Why people don't reprovision:</h3>
            <ul>
              <li>It takes too long.</li>
              <li>Reprovisioning fails.</li>
              <li>Data loss.</li>
            </ul>
            <aside class="notes">
Just because you've built a virtual dev environment, doesn't mean it will stay
You may have to push your developers to remain in sync.

Why don't people stay in sync?  It takes time.  If your provisioning process takes two hours, that's two hours of lost
productivity.  If it takes any longer than a coffee break, developers will resist reprovisioning.
            </aside>
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <h3>Why people don't reprovision:</h3>
            <ul>
              <li>It takes too long.</li>
              <li>Reprovisioning fails.</li>
              <li><strike>Data loss.</strike></li>
            </ul>
            <aside class="notes">
We've already talked about data loss...  
            </aside>
          </section>


          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <br>
Provision of a customized box vs a generic box.

Again, benchmark!
          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <img src="img/tests.gif">
          </section>

        </section>


        <section>
          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <h2>Does it work?</h2>
            <br>
it does for us.  this january, we hired two new staff members.
we're a startup.  we don't really have a staff onboarding process.  it's pretty informal.
so we had brand new still-shrinkwrapped macbook pros.  and using the tools that i've outlined in this
talk, both people had a complete -- functional -- dev environment, and had both made (trivial) commits
to our codebase before lunch.  including code reviews.

          </section>

          <section data-background="img/symbol_reversed.svg" data-background-size="70%" data-background-position="120%">
            <h2>does it work?</h2>
            <br>
So it takes time up front.  And it you spend a little more time on each pageload in a dev environment.
But what you get for that, is _vastly_ reduced time building dev environments, and easier production.

You don't get this stuff out of the box by just using Vagrant.  


          </section>
        </section>

        <section class="main-title" data-background="img/symbol_reversed.svg" data-background-size="150%">
          <img src="img/fulllogo_reversed.svg" class="simple-img full-logo" />
          <h2>Thank you!</h2>
          <h3><a href="https://www.bithound.io">www.bithound.io</a></h3>
          <ul>
            <li>Tony Thompson (<a href="http://twitter.com/tonious">@tonious</a>)</li>
            <li><a href="http://bithound.github.io/2015-jsDay/">http://bithound.github.io/2015-jsDay/</a></li>
          </ul>
          </br>
          </br>
          <p>
            <small><a href="https://www.bithound.io">www.bithound.io</a> / <a href="http://twitter.com/bithoundio">@bithoundio</a></small>
          </p>  
        </section>
      </div>

    </div>

    <div class="footer">
      <!--<img src="img/wordmark_grey_reversed.svg" class="simple-img wordmark" />-->
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

    <!-- Live reload -->

  </body>
</html>
